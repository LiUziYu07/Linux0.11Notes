#  Linux0.11源代码阅读(参考赵炯Linux0.11)

## 一.微型计算机组成原理

CPU通过三条总线(地址总线、数据总线、控制总线)与系统中其他部分进行通信

### 1.现代计算机的总线结构

总线结构为了提高传输速率,与8086相比产生了很大的变化,使用两个超大规模芯片构成的芯片组和芯片集构成(南桥芯片与北桥芯片),但依旧与传统的PC机硬件上兼容.

![总线结构](%E7%B4%A0%E6%9D%90/%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84.jpg)

#### I/O端口和访问控制方式

CPU需要地址才可以访问控制器或者控制卡上的数据和状态信息,就类似于查户口的工作人员需要知道你家的门牌号才能找到你家查户口.

##### 两种编址方法:统一编址和独立编址:

+ 统一编址:将I/O端口当作内存来寻址,CPU访问一个端口的操作与访问内存的操作一样

+ 独立编址:将I/O端口控制器和控制卡的寻址空间看作一个独立的空间来寻址.称为I/O地址空间,每个端口对应一个I/O地址,有专门的I/O指令访问端口

##### Linux采用的编址方式:

+ IBM PC机及其兼容机采用主要独立编址方式,使用ISA(工业标准体系结构)总线结构的传统PC及其I/O地址空间0x000–0x3FF有1024个端口可用

+ 但IBM  PC机也部分使用统一编址方式,例如CGA显示卡上显示内存的地址就直接占用了存储地址空间0xB800–0xBC00范围

+ Linux下可通过查看/proc/ioports文件可以得到相关控制器或设置使用的I/O地址范围:

  ![I:O端口](%E7%B4%A0%E6%9D%90/I:O%E7%AB%AF%E5%8F%A3.JPG)

+ 对于使用EISA或PCI等总线结构的现代PC机,有64KB的I/O地址空间可以使用

### 2接口访问控制

#### 接口数据的传输方式:一般采用循环查询方式、中断处理方式和DMA传输方式

+ 循环查询方式,无需过多硬件支持,但耗费CPU时间较多,Linux中很少使用(仅当设备或控制器能立刻返回信息时)

+ 中断处理需要中断控制器的支持,Linux中绝大多数设备I/O控制都采用中断处理

+ DMA传输方式:需要DMA控制器,无需CPU,效率较高,Linux中软盘驱动程序使用中断和DMA方式配合来实现数据的传输

### 3.存储器

+ 主存

  现代CPU的物理内存寻址范围高达4GB,为了与原来的PC机在软件上兼容,系统1MB以下物理内存使用分配上仍然保持与原来PC机基本一致,而BIOS原来所在的位置,仍然用于复制BIOS代码.

###### 启动计算机

计算机家电初始化后,有4GB的物理地址空间,除了地址0xA0000到0xFFFFF和0xFFFE00到0xFFFFFFFF范围以外的内存均可用作系统内存.这两个区域被用于I/O设备和BIOS程序

假定计算机中有16MB物理内存

+ 0——640K将被用于存放内核代码和数据
+ 640K——1M之间的384K仍然保留用作图中之名的用途
  + 0xA0000开始的128K用作显示内存缓冲区,随后部分用于其他控制卡的ROM BIOS或其映射区域,
  + 0xF000到1M范围用于高端系统ROM BIOS的映射区
+ 1M——16M被内核用于可分配的主内存区
+ 高速缓存区和内存虚拟盘也会占用内核代码和数据后面一部分区域,该区域通常会跨越640K——1M

### 4.BIOS

![BIOS](%E7%B4%A0%E6%9D%90/BIOS.jpg)存放在ROM中的系统BIOS程序主要用于系统各部分的自检,除了在初始化时利用BIOS提供系统参数,Linux在运行时不使用BIOS

#### 计算机启动的加载过程

+ 按下计算机的复位键后,CPU会自动把寄存器CS设为0xF000,其段基地址则设置为:0xFFFFFFF0000,段长度设置为64KB,而IP被设置为0xFFF0​,此时CPU代码指向0xFFFFFFF0处,即4G空间最后一个64K的最后16字节处.此处存放的是ROM BIOS.
+ BIOS在此处存放一条跳转指令JMP跳转到BIOS代码中64KB范围内的某一条指令开始执行
+ 现代微机中BIOS容量大多有1MB和2MB,并存储在ROM中,为了访问其他BIOS采用32位大模式,把数据段寄存器的访问范围设为4G.
+ 完成了硬件检测和初始化操作后,就会把与原来PC机兼容的64KB BIOS代码和数据复制到内存低端1M的末端64K处
+ 跳转至这个位置,CPU进入实地址模式工作
+ 最终BIOS从硬盘把操作系统引导程序加载到内存0x7c00处,跳转到这个位置执行引导程序

![计算机启动](%E7%B4%A0%E6%9D%90/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%90%AF%E5%8A%A8.jpg)

####  CMOS存储器

PC机中还使用少量的CMOS存储器来存放计算机的实时时钟信息和系统硬件配置信息,CMOS存储器需要使用I/O指令来访问.

###  5.控制器和控制卡

#### 中断控制器

用于实现I/O设备的中断控制数据存取方式.初始化时在内存0x000-0xFFF区域建立一个中断向量表

#### DMA控制器

通过让外部设备直接与内存传输来增加系统的性能.通常由Intel 8237芯片或其兼容芯片实现.利用通道实现其功能

#### 定时/计数器

Intel 8253/8254用于处理计算机中的精确时间延迟.Linux0.11操作系统只对通道0进程了重新设置,每间隔10ms发出一个信号以产生中断请求信号,用于定时切换当前执行的任务和统计每个任务使用的系统资源量

#### 键盘控制器

键盘上有一个被称为键盘编码器的处理器用于扫描所有按键按下和松开的信息,并将其发送到主机主板上的键盘控制器.

键盘控制器采用Intel 8042 单片微处理芯片或其兼容电路接受键盘发来的11为串行格式数据.

#### 串行控制卡

1. 异步串行通信原理

   计算机与计算机之间的语言被称为通信协议,规定了传送有效数据长度单位的格式.通常使用帧来描述这种格式.

   串行通信是指在线路上以比特流一次一个比特进行传输的通信方式.

   + 同步串行通信:多个字符或字节作为一帧
   + 异步串行通信:一个字符或者一个通信单位为一帧

2. 异步串行传输格式

   由起始位、数据位、奇偶检验位和停止位构成.起始位其同步作用.

3. 串行控制器

   PC机上通常带有2个串行接口,并使用串行控制器来处理串行数据的收发工作.

####  显示控制

Linux0.11仅使用了现代各种标准都支持的文本显示方式

1. MDA显示标准:配置有8K显示内寸,占用内存(0xb0000——0xb20000)
2. CGA显示标准:标配16KB显示内存,占用内存(0xb8000——0xbc000)
3. EGA/VGA显示标准:标配32KB的显示内存,占用内存(0xa0000)

####  软盘和硬盘控制器

PC机的软盘控制子系统由软盘片和软盘驱动器组成

硬盘是由盘片和驱动器组成.

硬盘、软盘都市利用磁性介质保存信息

###### 磁盘控制器

磁盘控制器是CPU和驱动器之间的逻辑接口电流.

![磁盘控制器](%E7%B4%A0%E6%9D%90/%E7%A3%81%E7%9B%98%E6%8E%A7%E5%88%B6%E5%99%A8.jpg)

## 二.内核编程语言和环境

### as86汇编器

Linux0.11中使用了两种汇编器,二者语法不兼容:

1. as86汇编器,使用配套的ld86链接器

   近似MASM,使用Intel的汇编语言语法,基于MINIX的汇编语法

   Linux仅用它创建16位的启动引导扇区程序boot\bootsect.s和实模式下初始设置程序boot/setup.s的代码

   这两个程序具体做的事情(BIOS检查完毕后,会把CS:IP设置为0x07c0，ip=0x0000),因此把引导程序放在这个位置

   https://www.cnblogs.com/ronny/p/7787259.html

2. GUN的汇编器gas,使用GNU ld链接器

   内核其余所有汇编语言程序均水涌gas编译

   

##三.Linux0.11保护模式

Linux中断

https://blog.csdn.net/FactorX/article/details/46340891

Linux0.11内核基于80X86 CPU

#### 简单的多任务内核实例

1. 启动引导程序boot.s(as86汇编语言)和保护模式的多任务内核程序head.s(GNU as汇编语言)

+ boot程序的主要功能是把软盘或者映像文件中的head内核代码加载到内存的指定位置,设置好临时GDT信息后,把处理设置成运行在保护模式下,跳转到head代码处区运行内核带代码.
+ 简单来说,boot的任务是利用ROM BIOS中断把head中的diamanté先读到一个位置,之后将这段代码复制到0处,设置好保护模式之后,跳转到0处执行head代码![boot.s的作用](%E7%B4%A0%E6%9D%90/boot.s%E7%9A%84%E4%BD%9C%E7%94%A8.jpg)
+ 使用ROM BIOS中断int 0x13,之后在内核初始化时重新设置中断控制芯片